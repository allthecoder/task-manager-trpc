# Task Manager (Next.js + tRPC)

A simple in-memory task management application built with **Next.js (App
Router)** and **tRPC**.

This project was developed as a technical challenge and focuses on clean
architecture, type safety, SSR integration, and incremental data loading
with infinite scroll.

------------------------------------------------------------------------

## Tech Stack

-   **Next.js 15+ (App Router)**
-   **React 18**
-   **tRPC v11**
-   **React Query (@tanstack/react-query)**
-   **Zod** (schema validation)
-   **SuperJSON** (data serialization)
-   **TypeScript**

------------------------------------------------------------------------

##  Features

### Backend (tRPC)

-   In-memory data store (no database)
-   Full CRUD operations:
    -   Create Task
    -   List Tasks
    -   Update Task
    -   Delete Task
-   Cursor-based pagination for infinite scroll
-   Input validation with Zod
-   Proper error handling (including NOT_FOUND)

Each task contains:

``` ts
{
  id: string (autogenerated)
  title: string
  description?: string (optional)
  createdAt: Date
}
```

------------------------------------------------------------------------

### Frontend (Next.js + React)

-   Server-Side Rendering (SSR) for initial task list
-   Infinite Scroll with cursor pagination
-   Virtualized window (only 5 items visible at a time)
-   Scroll-triggered incremental loading
-   Task creation and editing forms
-   Client-side validation
-   Error feedback and success states
-   Consistent UI styling with custom CSS variables

------------------------------------------------------------------------

## How It Works

### Architecture Overview

The application follows a clear separation of concerns:

-   `src/server/` → Backend logic (tRPC routers)
-   `src/app/` → Next.js pages (App Router)
-   `src/app/api/trpc/[trpc]/route.ts` → tRPC API handler
-   `src/app/tasks/TaskList.tsx` → Infinite scroll + virtualization
    logic

### Data Flow

1.  The initial task list is fetched server-side using `createCaller()`
    (SSR).
2.  The frontend hydrates with `useInfiniteQuery`.
3.  When the user scrolls near the bottom:
    -   The next cursor is requested.
    -   New tasks are appended.
4.  Only a window of 5 items is rendered at any time for performance and
    UX consistency.

------------------------------------------------------------------------

## Project Structure

    src/
     ├── app/
     │    ├── api/trpc/[trpc]/route.ts
     │    ├── tasks/
     │    │     ├── page.tsx
     │    │     ├── [id]/page.tsx
     │    │     ├── new/page.tsx
     │    │     └── TaskList.tsx
     │    └── layout.tsx
     │
     └── server/
          ├── root.ts
          ├── trpc.ts
          └── routers/task.router.ts

------------------------------------------------------------------------

## Running the Project

## Prerequisites

Make sure you have the following installed:

- Node.js 18+ (recommended: Node 20 LTS)
- npm (comes with Node)

You can check your version with:

```bash
node -v
npm -v
```

### 1. Clone the repository

``` bash
git clone <this-repository-url>
cd task-manager-trpc
```

### 2. Install dependencies

``` bash
npm install
```

### 3. Run the development server

``` bash
npm run dev
```

The application will be available at:

    http://localhost:3000/tasks

------------------------------------------------------------------------

## Notes

-   This project uses an **in-memory data store**.
-   All tasks will be lost when the server restarts.
-   No environment variables or sensitive credentials are required.

------------------------------------------------------------------------

## Infinite Scroll Implementation

The infinite scroll uses:

-   Cursor-based pagination in the backend
-   `useInfiniteQuery` from React Query
-   Scroll event detection
-   Virtualized rendering (window size = 5 items)

This ensures:

-   Incremental loading
-   No full dataset preloading
-   Smooth scroll UX similar to messaging apps

------------------------------------------------------------------------

## Design Decisions

-   Type safety end-to-end using tRPC
-   Zod validation for robust input handling
-   SSR for initial data hydration
-   Client-driven incremental loading
-   Minimal but structured UI
-   No external UI libraries (custom CSS styling)

------------------------------------------------------------------------

## Final Notes

This project prioritizes:

-   Simplicity
-   Clean architecture
-   Type safety
-   Performance-conscious rendering
-   Clear separation between backend and frontend
